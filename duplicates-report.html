<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Duplicates</title>
<style>
	pre {
		background-color: #FFD;
		border: 1px solid #E2E2E2;
		padding: 1ex;
	}
</style>
<h1>#1 found 2 clones</h1>
<h2>internal/handler/handlers.go:120</h2>
<pre>func (h *PortfolioHandlers) ExperiencesHandler(c *gin.Context) {
	ctx := context.Background()
	
	experiences, err := h.experienceService.ListExperiences(ctx, service.ExperienceFilter{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{&#34;error&#34;: &#34;Failed to load experiences&#34;})
		return
	}
	
	c.JSON(http.StatusOK, experiences)
}</pre>
<h2>internal/handler/handlers.go:133</h2>
<pre>func (h *PortfolioHandlers) ServicesHandler(c *gin.Context) {
	ctx := context.Background()
	
	services, err := h.portfolioService.ListServices(ctx, service.ServiceFilter{})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{&#34;error&#34;: &#34;Failed to load services&#34;})
		return
	}
	
	c.JSON(http.StatusOK, services)
}</pre>
<h1>#2 found 2 clones</h1>
<h2>internal/service/experience.go:192</h2>
<pre>func (s *ExperienceService) GetExperiencesByCompany(ctx context.Context, companyName string) ([]*domain.Experience, error) {
	if companyName == &#34;&#34; {
		return nil, domain.ErrInvalidInput(&#34;company name cannot be empty&#34;)
	}
	
	experiences, err := s.repo.GetByCompany(ctx, companyName)
	if err != nil {
		return nil, domain.ErrInternal(fmt.Sprintf(&#34;failed to get experiences by company: %v&#34;, err))
	}
	
	return experiences, nil
}</pre>
<h2>internal/service/technology.go:144</h2>
<pre>func (s *TechnologyService) GetTechnologiesByCategory(ctx context.Context, category string) ([]*domain.Technology, error) {
	if category == &#34;&#34; {
		return nil, domain.ErrInvalidInput(&#34;category cannot be empty&#34;)
	}
	
	technologies, err := s.repo.GetByCategory(ctx, category)
	if err != nil {
		return nil, domain.ErrInternal(fmt.Sprintf(&#34;failed to get technologies by category: %v&#34;, err))
	}
	
	return technologies, nil
}</pre>
<h1>#3 found 2 clones</h1>
<h2>internal/service/experience.go:121</h2>
<pre>func (s *ExperienceService) AddTechnologyToExperience(ctx context.Context, experienceID, technologyID string) error {
	// Get experience
	experience, err := s.GetExperience(ctx, experienceID)
	if err != nil {
		return err
	}
	
	// Get technology
	technology, err := s.techRepo.GetByID(ctx, technologyID)
	if err != nil {
		return domain.ErrNotFound(&#34;technology&#34;)
	}
	
	// Check if technology is already added
	for _, tech := range experience.Technologies {
		if tech.ID == technologyID {
			return domain.ErrConflict(&#34;technology already added to experience&#34;)
		}
	}
	
	// Add technology
	experience.AddTechnology(*technology)
	
	if err := s.repo.Update(ctx, experience); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to add technology to experience: %v&#34;, err))
	}
	
	return nil
}

// AddAchievementToExperience adds an achievement to an experience
func (s *ExperienceService) AddAchievementToExperience(ctx context.Context, experienceID string, achievement AchievementRequest) error {
	// Get experience
	experience, err := s.GetExperience(ctx, experienceID)
	if err != nil {
		return err
	}
	
	// Create achievement
	ach := domain.NewAchievement(achievement.Title, achievement.Description, achievement.Impact)
	ach.ID = generateID()
	
	// Add achievement
	experience.AddAchievement(*ach)
	
	if err := s.repo.Update(ctx, experience); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to add achievement to experience: %v&#34;, err))
	}
	
	return nil
}

// EndExperience sets the end date for an experience
func (s *ExperienceService) EndExperience(ctx context.Context, id string, endDate time.Time) error {
	experience, err := s.GetExperience(ctx, id)
	if err != nil {
		return err
	}
	
	if err := experience.SetEndDate(endDate); err != nil {
		return err
	}
	
	if err := s.repo.Update(ctx, experience); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to end experience: %v&#34;, err))
	}
	
	return nil
}</pre>
<h2>internal/service/portfolio.go:131</h2>
<pre>func (s *PortfolioService) AddTechnologyToService(ctx context.Context, serviceID, technologyID string) error {
	// Get service
	service, err := s.GetService(ctx, serviceID)
	if err != nil {
		return err
	}
	
	// Get technology
	technology, err := s.techRepo.GetByID(ctx, technologyID)
	if err != nil {
		return domain.ErrNotFound(&#34;technology&#34;)
	}
	
	// Check if technology is already added
	for _, tech := range service.Technologies {
		if tech.ID == technologyID {
			return domain.ErrConflict(&#34;technology already added to service&#34;)
		}
	}
	
	// Add technology
	service.AddTechnology(*technology)
	
	if err := s.repo.Update(ctx, service); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to add technology to service: %v&#34;, err))
	}
	
	return nil
}

// AddDeliverableToService adds a deliverable to a service
func (s *PortfolioService) AddDeliverableToService(ctx context.Context, serviceID string, deliverable DeliverableRequest) error {
	// Get service
	service, err := s.GetService(ctx, serviceID)
	if err != nil {
		return err
	}
	
	// Create deliverable
	del := domain.NewDeliverable(deliverable.Name, deliverable.Description, deliverable.Timeline)
	del.ID = generateID()
	
	// Add deliverable
	service.AddDeliverable(*del)
	
	if err := s.repo.Update(ctx, service); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to add deliverable to service: %v&#34;, err))
	}
	
	return nil
}

// UpdateServicePricing updates the pricing for a service
func (s *PortfolioService) UpdateServicePricing(ctx context.Context, serviceID string, pricing domain.PricingInfo) error {
	service, err := s.GetService(ctx, serviceID)
	if err != nil {
		return err
	}
	
	if err := service.SetPricing(pricing); err != nil {
		return err
	}
	
	if err := s.repo.Update(ctx, service); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to update service pricing: %v&#34;, err))
	}
	
	return nil
}</pre>
<h1>#4 found 3 clones</h1>
<h2>internal/container/memory_repositories.go:32</h2>
<pre>func (r *InMemoryTechnologyRepository) GetByID(ctx context.Context, id string) (*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	tech, exists := r.techs[id]
	if !exists {
		return nil, domain.ErrNotFound(&#34;technology&#34;)
	}
	return tech, nil
}</pre>
<h2>internal/container/memory_repositories.go:133</h2>
<pre>func (r *InMemoryExperienceRepository) GetByID(ctx context.Context, id string) (*domain.Experience, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	exp, exists := r.exps[id]
	if !exists {
		return nil, domain.ErrNotFound(&#34;experience&#34;)
	}
	return exp, nil
}</pre>
<h2>internal/container/memory_repositories.go:248</h2>
<pre>func (r *InMemoryServiceRepository) GetByID(ctx context.Context, id string) (*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	svc, exists := r.services[id]
	if !exists {
		return nil, domain.ErrNotFound(&#34;service&#34;)
	}
	return svc, nil
}</pre>
<h1>#5 found 2 clones</h1>
<h2>internal/service/portfolio.go:117</h2>
<pre>func (s *PortfolioService) GetServicesByCategory(ctx context.Context, category domain.ServiceType) ([]*domain.Service, error) {
	if !category.IsValid() {
		return nil, domain.ErrInvalidInput(&#34;invalid service category&#34;)
	}
	
	services, err := s.repo.GetByCategory(ctx, category)
	if err != nil {
		return nil, domain.ErrInternal(fmt.Sprintf(&#34;failed to get services by category: %v&#34;, err))
	}
	
	return services, nil
}</pre>
<h2>internal/service/technology.go:158</h2>
<pre>func (s *TechnologyService) GetTechnologiesByLevel(ctx context.Context, level domain.Level) ([]*domain.Technology, error) {
	if !level.IsValid() {
		return nil, domain.ErrInvalidInput(&#34;invalid technology level&#34;)
	}
	
	technologies, err := s.repo.GetByLevel(ctx, level)
	if err != nil {
		return nil, domain.ErrInternal(fmt.Sprintf(&#34;failed to get technologies by level: %v&#34;, err))
	}
	
	return technologies, nil
}</pre>
<h1>#6 found 3 clones</h1>
<h2>internal/service/experience.go:72</h2>
<pre>func (s *ExperienceService) GetExperience(ctx context.Context, id string) (*domain.Experience, error) {
	if id == &#34;&#34; {
		return nil, domain.ErrInvalidInput(&#34;experience ID cannot be empty&#34;)
	}
	
	experience, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, domain.ErrNotFound(&#34;experience&#34;)
	}
	
	return experience, nil
}</pre>
<h2>internal/service/portfolio.go:70</h2>
<pre>func (s *PortfolioService) GetService(ctx context.Context, id string) (*domain.Service, error) {
	if id == &#34;&#34; {
		return nil, domain.ErrInvalidInput(&#34;service ID cannot be empty&#34;)
	}
	
	service, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, domain.ErrNotFound(&#34;service&#34;)
	}
	
	return service, nil
}</pre>
<h2>internal/service/technology.go:57</h2>
<pre>func (s *TechnologyService) GetTechnology(ctx context.Context, id string) (*domain.Technology, error) {
	if id == &#34;&#34; {
		return nil, domain.ErrInvalidInput(&#34;technology ID cannot be empty&#34;)
	}
	
	tech, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, domain.ErrNotFound(&#34;technology&#34;)
	}
	
	return tech, nil
}</pre>
<h1>#7 found 2 clones</h1>
<h2>internal/container/memory_repositories.go:85</h2>
<pre>func (r *InMemoryTechnologyRepository) GetByCategory(ctx context.Context, category string) ([]*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Technology
	for _, tech := range r.techs {
		if tech.Category == category {
			result = append(result, tech)
		}
	}
	
	return result, nil
}</pre>
<h2>internal/container/memory_repositories.go:183</h2>
<pre>func (r *InMemoryExperienceRepository) GetByCompany(ctx context.Context, companyName string) ([]*domain.Experience, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Experience
	for _, exp := range r.exps {
		if exp.CompanyName == companyName {
			result = append(result, exp)
		}
	}
	
	return result, nil
}</pre>
<h1>#8 found 2 clones</h1>
<h2>internal/service/portfolio.go:202</h2>
<pre>func (s *PortfolioService) ActivateService(ctx context.Context, id string) error {
	service, err := s.GetService(ctx, id)
	if err != nil {
		return err
	}
	
	service.Activate()
	
	if err := s.repo.Update(ctx, service); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to activate service: %v&#34;, err))
	}
	
	return nil
}</pre>
<h2>internal/service/portfolio.go:218</h2>
<pre>func (s *PortfolioService) DeactivateService(ctx context.Context, id string) error {
	service, err := s.GetService(ctx, id)
	if err != nil {
		return err
	}
	
	service.Deactivate()
	
	if err := s.repo.Update(ctx, service); err != nil {
		return domain.ErrInternal(fmt.Sprintf(&#34;failed to deactivate service: %v&#34;, err))
	}
	
	return nil
}</pre>
<h1>#9 found 2 clones</h1>
<h2>internal/container/memory_repositories.go:99</h2>
<pre>func (r *InMemoryTechnologyRepository) GetByLevel(ctx context.Context, level domain.Level) ([]*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Technology
	for _, tech := range r.techs {
		if tech.Level == level {
			result = append(result, tech)
		}
	}
	
	return result, nil
}</pre>
<h2>internal/container/memory_repositories.go:315</h2>
<pre>func (r *InMemoryServiceRepository) GetByCategory(ctx context.Context, category domain.ServiceType) ([]*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Service
	for _, svc := range r.services {
		if svc.Category == category {
			result = append(result, svc)
		}
	}
	
	return result, nil
}</pre>
<h1>#10 found 2 clones</h1>
<h2>internal/container/memory_repositories.go:32</h2>
<pre>func (r *InMemoryTechnologyRepository) GetByID(ctx context.Context, id string) (*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	tech, exists := r.techs[id]
	if !exists {
		return nil, domain.ErrNotFound(&#34;technology&#34;)
	}
	return tech, nil
}

func (r *InMemoryTechnologyRepository) GetByName(ctx context.Context, name string) (*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	for _, tech := range r.techs {
		if tech.Name == name {
			return tech, nil
		}
	}
	return nil, domain.ErrNotFound(&#34;technology&#34;)
}

func (r *InMemoryTechnologyRepository) List(ctx context.Context, filter repository.TechnologyFilter) ([]*domain.Technology, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Technology
	for _, tech := range r.techs {
		if filter.Category != nil &amp;&amp; tech.Category != *filter.Category {
			continue
		}
		if filter.Level != nil &amp;&amp; tech.Level != *filter.Level {
			continue
		}
		result = append(result, tech)
	}
	
	return result, nil
}</pre>
<h2>internal/container/memory_repositories.go:248</h2>
<pre>func (r *InMemoryServiceRepository) GetByID(ctx context.Context, id string) (*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	svc, exists := r.services[id]
	if !exists {
		return nil, domain.ErrNotFound(&#34;service&#34;)
	}
	return svc, nil
}

func (r *InMemoryServiceRepository) GetByName(ctx context.Context, name string) (*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	for _, svc := range r.services {
		if svc.Name == name {
			return svc, nil
		}
	}
	return nil, domain.ErrNotFound(&#34;service&#34;)
}

func (r *InMemoryServiceRepository) List(ctx context.Context, filter repository.ServiceFilter) ([]*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Service
	for _, svc := range r.services {
		if filter.Category != nil &amp;&amp; svc.Category != *filter.Category {
			continue
		}
		if filter.IsActive != nil &amp;&amp; svc.IsActive != *filter.IsActive {
			continue
		}
		result = append(result, svc)
	}
	
	return result, nil
}</pre>
<h1>#11 found 2 clones</h1>
<h2>internal/container/memory_repositories.go:211</h2>
<pre>func (r *InMemoryExperienceRepository) GetWithTechnology(ctx context.Context, technologyName string) ([]*domain.Experience, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Experience
	for _, exp := range r.exps {
		for _, tech := range exp.Technologies {
			if tech.Name == technologyName {
				result = append(result, exp)
				break
			}
		}
	}
	
	return result, nil
}</pre>
<h2>internal/container/memory_repositories.go:329</h2>
<pre>func (r *InMemoryServiceRepository) GetWithTechnology(ctx context.Context, technologyName string) ([]*domain.Service, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	var result []*domain.Service
	for _, svc := range r.services {
		for _, tech := range svc.Technologies {
			if tech.Name == technologyName {
				result = append(result, svc)
				break
			}
		}
	}
	
	return result, nil
}</pre>
